/* ntpshmread.c -- monitor the inner end of an ntpshmwrite.connection
 *
 * This file is Copyright (c) 2010 by the GPSD project
 * BSD terms apply: see the file COPYING in the distribution root for details.
 *
 * Some of this was swiped from the NTPD distribution.
 */
#define _XOPEN_SOURCE 600
#include <string.h>
#include <stdbool.h>
#include <math.h>
#include <errno.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <assert.h>
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include "ntpshm.h"

/* initialize a SHM segment */
struct shmTime *shm_get(const unsigned int unit, const unsigned char create)
{
    struct shmTime *p = NULL;
    int shmid;

    /*
     * Big units will give non-ASCII but that's OK
     * as long as everybody does it the same way.
     */
    if (unit & 0x03) {
        return NULL;
    }
    shmid = shmget((key_t)(NTPD_BASE + unit), sizeof(struct shmTime),
		           (create ? IPC_CREAT : 0) | 0666);
    if (shmid == -1) { /* error */
	    return NULL;
    }
    p = (struct shmTime *)shmat (shmid, 0, 0);
    if (p == (struct shmTime *)-1) { /* error */
	    return NULL;
    }
    return p;
}

/* return the name of a specified segment */
char *ntp_name(const unsigned int unit)
{
    static char name[5] = "NTP\0";
    name[3] = (char)('0' + unit);
    return name;
}

/* try to grab a sample from the specified SHM segment */
enum segstat_t ntp_read(struct shmTime *shm_in, struct shm_stat_t *shm_stat, const unsigned char consume)
{
    volatile struct shmTime shmcopy, *shm = shm_in;
    unsigned int cnt, cns_new, rns_new;

    if (shm == NULL) {
	    shm_stat->status = NO_SEGMENT;
	    return NO_SEGMENT;
    }

    shm_stat->tvc.tv_sec = shm_stat->tvc.tv_nsec = 0;

    clock_gettime(CLOCK_REALTIME, &shm_stat->tvc);

    /* relying on word access to be atomic here */
    if (shm->valid == 0) {
	    shm_stat->status = NOT_READY;
	    return NOT_READY;
    }
    cnt = shm->count;

    /*
     * This is proof against concurrency issues if either (a) the
     * memory_barrier() call works on this host, or (b) memset
     * compiles to an uninterruptible single-instruction bitblt (this
     * will probably cease to be true if the structure exceeds your VM
     * page size).
     */
    __asm__ __volatile__("":::"memory");
    memcpy((void *)&shmcopy, (void *)shm, sizeof(struct shmTime));

    /*
     * An update consumer such as ntpd should zero the valid flag at this point.
     * A program snooping the updates to collect statistics should not, lest
     * it make the data unavailable for consumers.
     */
    if (consume)
	    shm->valid = 0;
    __asm__ __volatile__("":::"memory");

    /*
     * Clash detection in case neither (a) nor (b) was true.
     * Not supported in mode 0, and word access to the count field
     * must be atomic for this to work.
     */
    if (shmcopy.mode > 0 && cnt != shm->count) {
	    shm_stat->status = CLASH;
	    return shm_stat->status;
    }

    shm_stat->status = OK;

    switch (shmcopy.mode) {
    case 0:
	shm_stat->tvr.tv_sec	= shmcopy.receiveTimeStampSec;
	shm_stat->tvr.tv_nsec	= shmcopy.receiveTimeStampUSec * 1000;
	rns_new		= shmcopy.receiveTimeStampNSec;
	shm_stat->tvt.tv_sec	= shmcopy.clockTimeStampSec;
	shm_stat->tvt.tv_nsec	= shmcopy.clockTimeStampUSec * 1000;
	cns_new		= shmcopy.clockTimeStampNSec;

	/* Since the following comparisons are between unsigned
	** variables they are always well defined, and any
	** (signed) underflow will turn into very large unsigned
	** values, well above the 1000 cutoff.
	**
	** Note: The usecs *must* be a *truncated*
	** representation of the nsecs. This code will fail for
	** *rounded* usecs, and the logic to deal with
	** wrap-arounds in the presence of rounded values is
	** much more convoluted.
	*/
	if (((cns_new - (unsigned)shm_stat->tvt.tv_nsec) < 1000)
	       && ((rns_new - (unsigned)shm_stat->tvr.tv_nsec) < 1000)) {
	    shm_stat->tvt.tv_nsec = cns_new;
	    shm_stat->tvr.tv_nsec = rns_new;
	}
	/* At this point shm_stat->tvr and shm_stat->tvt contain valid ns-level
	** timestamps, possibly generated by extending the old
	** us-level timestamps
	*/
	break;

    case 1:
	shm_stat->tvr.tv_sec	= shmcopy.receiveTimeStampSec;
	shm_stat->tvr.tv_nsec	= shmcopy.receiveTimeStampUSec * 1000;
	rns_new		= shmcopy.receiveTimeStampNSec;
	shm_stat->tvt.tv_sec	= shmcopy.clockTimeStampSec;
	shm_stat->tvt.tv_nsec	= shmcopy.clockTimeStampUSec * 1000;
	cns_new		= shmcopy.clockTimeStampNSec;

	/* See the case above for an explanation of the
	** following test.
	*/
	if (((cns_new - (unsigned)shm_stat->tvt.tv_nsec) < 1000)
	       && ((rns_new - (unsigned)shm_stat->tvr.tv_nsec) < 1000)) {
	    shm_stat->tvt.tv_nsec = cns_new;
	    shm_stat->tvr.tv_nsec = rns_new;
	}
	/* At this point shm_stat->tvr and shm_stat->tvt contains valid ns-level
	** timestamps, possibly generated by extending the old
	** us-level timestamps
	*/
	break;

    default:
	    shm_stat->status = BAD_MODE;
	    break;
    }

    /*
     * leap field is not a leap offset but a leap notification code.
     * The values are magic numbers used by NTP and set by GPSD, if at all, in
     * the subframe code.
     */
    shm_stat->leap = shmcopy.leap;
    shm_stat->precision = shmcopy.precision;
    return shm_stat->status;
}

#define LEAP_NOWARNING  0x0     /* normal, no leap second warning */

/* put a received fix time into shared memory for NTP */
void ntp_write(volatile struct shmTime *shmseg, struct timedelta_t *td, int precision)
{
    /* we use the shmTime mode 1 protocol
     *
     * ntpd does this:
     *
     * reads valid.
     * IFF valid is 1
     *    reads count
     *    reads values
     *    reads count
     *    IFF count unchanged
     *        use values
     *    clear valid
     */

    shmseg->valid = 0;
    shmseg->count++;
    /* We need a memory barrier here to prevent write reordering by
     * the compiler or CPU cache */
    __asm__ __volatile__("sfence \n\t":::"memory");
    shmseg->clockTimeStampSec = (time_t)td->real.tv_sec;
    shmseg->clockTimeStampUSec = (int)(td->real.tv_nsec/1000);
    shmseg->clockTimeStampNSec = (unsigned)td->real.tv_nsec;
    shmseg->receiveTimeStampSec = (time_t)td->clock.tv_sec;
    shmseg->receiveTimeStampUSec = (int)(td->clock.tv_nsec/1000);
    shmseg->receiveTimeStampNSec = (unsigned)td->clock.tv_nsec;
    shmseg->leap = LEAP_NOWARNING;
    shmseg->precision = precision;
    __asm__ __volatile__("":::"memory");
    shmseg->count++;
    shmseg->valid = 1;
}

